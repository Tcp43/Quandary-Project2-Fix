package parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.Symbol;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;

import ast.*;
import interpreter.Interpreter;

parser code {:
  Lexer lexer;

  public Parser(Lexer lex, ComplexSymbolFactory sf) {
    super(lex, sf);
    lexer = lex;
  }

  public void report_fatal_error(String message, Object info) {
    Interpreter.fatalError(message + " (" + info + ")", Interpreter.EXIT_PARSING_ERROR);
  }

  ast.Location loc(int line, int column) {
    return new ast.Location(line, column);
  }
:};

terminal PLUS, MINUS, LPAREN, RPAREN, RETURN, SEMICOLON, TIMES, UMINUS,
         INT, LCURLY, RCURLY, ASSIGN, IF, ELSE, PRINT,
         GE, LE, GT, LT, EQ, NE, AND, OR, NOT, RANDOMINT, COMMA, MAIN;
terminal Long INTCONST;
terminal String IDENT;

non terminal Program program;
non terminal Stmt stmt;
non terminal StmtList stmtList;
non terminal Expr expr;
non terminal BinaryExpr binaryExpr;
non terminal Cond cond;
non terminal java.util.List<FunctionDecl> fdecls;
non terminal FunctionDecl fdecl;
non terminal java.util.List<String> params;
non terminal java.util.List<Expr> args;

precedence left OR;
precedence left AND;
precedence left NOT;
precedence left GE, LE, GT, LT, EQ, NE;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left UMINUS;
precedence left ELSE;

start with program;
  
program ::=
    fdecls:fs
    INT MAIN LPAREN INT IDENT:argName RPAREN LCURLY stmtList:sl RCURLY fdecls:gs
    {:
       java.util.ArrayList<FunctionDecl> all =new java.util.ArrayList<FunctionDecl>(fs);
       all.addAll(gs);
       RESULT = new Program(argName, sl, all, loc(argNameleft, argNameright));
    :}
  ;

fdecls ::=
    fdecls:fs fdecl:fd
      {: fs.add(fd); RESULT = fs; :}
  | 
      {: RESULT = new java.util.ArrayList<FunctionDecl>(); :}
  ;

fdecl ::=
    INT IDENT:fname LPAREN params:ps RPAREN
    LCURLY stmtList:sl RCURLY:rb
      {: RESULT = new FunctionDecl(fname, ps, sl, loc(fnameleft, rbright)); :}
  ;

params ::=
      {: RESULT = new java.util.ArrayList<String>(); :}
  | INT IDENT:p
      {:
         java.util.ArrayList<String> ps = new java.util.ArrayList<String>();
         ps.add(p);
         RESULT = ps;
      :}
  | params:ps COMMA INT IDENT:p
      {: ps.add(p); RESULT = ps; :}
  ;

stmtList ::=
    stmt:s stmtList:sl
      {: RESULT = new StmtList(s, sl, loc(sleft, sright)); :}
  | 
      {: RESULT = null; :}
  ;

stmt ::=
    INT IDENT:varName ASSIGN expr:e SEMICOLON
      {: RESULT = new DeclStmt(varName, e, loc(varNameleft, varNameright)); :}
  | IF LPAREN cond:c RPAREN stmt:s
      {: RESULT = new IfStmt(c, s, null, loc(cleft, cright)); :}

  | IDENT:varName ASSIGN expr:e SEMICOLON
      {: RESULT = new AssignStmt(varName, e, loc(varNameleft, varNameright)); :}
    
  | IF LPAREN cond:c RPAREN stmt:s1 ELSE stmt:s2
      {: RESULT = new IfStmt(c, s1, s2, loc(cleft, cright)); :}
  | PRINT expr:e SEMICOLON
      {: RESULT = new PrintStmt(e, loc(eleft, eright)); :}
  | RETURN expr:e SEMICOLON
      {: RESULT = new ReturnStmt(e, loc(eleft, eright)); :}
  | LCURLY stmtList:sl RCURLY
      {: RESULT = sl; :}
  ;

expr ::=
    INTCONST:c
      {: RESULT = new ConstExpr(c, loc(cleft, cright)); :}
  
  | IDENT:fname LPAREN args:as RPAREN:rpar
    {: RESULT = new CallExpr(fname, as, loc(fnameleft, rparright)); :}
      
  | IDENT:varName
      {: RESULT = new IdentExpr(varName, loc(varNameleft, varNameright)); :}
  | RANDOMINT:ri LPAREN RPAREN:rp
      {: RESULT = new RandomIntExpr(loc(rileft, rpright)); :}

  | RANDOMINT:ri LPAREN expr:e RPAREN:rp
      {: RESULT = new RandomIntBoundedExpr(e, loc(rileft, rpright)); :}

| MAIN:m LPAREN expr:e RPAREN:rpar
    {:
       java.util.ArrayList<Expr> as = new java.util.ArrayList<Expr>();
       as.add(e);
       RESULT = new CallExpr("main", as, loc(mleft, rparright));
    :}
    
  | MINUS expr:e 
      {: RESULT = new UnaryMinusExpr(e, loc(eleft, eright)); :}
      %prec UMINUS
  | binaryExpr:e
      {: RESULT = e; :}
  | LPAREN expr:e RPAREN
      {: RESULT = e; :}
  ;

args ::=
      {: RESULT = new java.util.ArrayList<Expr>(); :}
  | expr:e
      {:
         java.util.ArrayList<Expr> as = new java.util.ArrayList<Expr>();
         as.add(e);
         RESULT = as;
      :}
  | args:as COMMA expr:e
      {: as.add(e); RESULT = as; :}
  ;

binaryExpr ::=
    expr:e1 PLUS expr:e2
      {: RESULT = new BinaryExpr(e1, BinaryExpr.PLUS, e2, loc(e1left, e2right)); :}
  | expr:e1 MINUS expr:e2
      {: RESULT = new BinaryExpr(e1, BinaryExpr.MINUS, e2, loc(e1left, e2right)); :}
  | expr:e1 TIMES expr:e2
      {: RESULT = new BinaryExpr(e1, BinaryExpr.TIMES, e2, loc(e1left, e2right)); :}
  ;

cond ::=
    expr:e1 LE expr:e2
      {: RESULT = new CompCond(e1, CompCond.LE, e2, loc(e1left, e2right)); :}
  | expr:e1 GE expr:e2
      {: RESULT = new CompCond(e1, CompCond.GE, e2, loc(e1left, e2right)); :}
  | expr:e1 LT expr:e2
      {: RESULT = new CompCond(e1, CompCond.LT, e2, loc(e1left, e2right)); :}
  | expr:e1 GT expr:e2
      {: RESULT = new CompCond(e1, CompCond.GT, e2, loc(e1left, e2right)); :}
  | expr:e1 EQ expr:e2
      {: RESULT = new CompCond(e1, CompCond.EQ, e2, loc(e1left, e2right)); :}
  | expr:e1 NE expr:e2
      {: RESULT = new CompCond(e1, CompCond.NE, e2, loc(e1left, e2right)); :}
  | cond:e1 AND cond:e2
      {: RESULT = new LogicalCond(e1, LogicalCond.AND, e2, loc(e1left, e2right)); :}
  | cond:e1 OR cond:e2
      {: RESULT = new LogicalCond(e1, LogicalCond.OR, e2, loc(e1left, e2right)); :}
  | NOT cond:e
      {: RESULT = new LogicalCond(e, LogicalCond.NOT, null, loc(eleft, eright)); :}
  | LPAREN cond:c RPAREN
      {: RESULT = c; :}
  ;
